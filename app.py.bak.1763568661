from flask import Flask, render_template, request, jsonify, make_response, g, session
import uuid, hashlib, json, datetime, os
from functools import wraps

# Security imports
import re
import secrets
import hmac
from flask import abort
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address


# --- QUICK HARDENING CONFIG (Phase 4 Pre-Upgrades) ---
LOG_MAX_BYTES = int(os.environ.get("LOG_MAX_BYTES", 512 * 1024))  # 512KB
LOG_BACKUPS   = int(os.environ.get("LOG_BACKUPS", 5))
LOG_HMAC_KEY  = os.environ.get("LOG_HMAC_KEY", "")  # set to random hex for tamper-evidence

ALLOWED_ORIGIN_HOST = os.environ.get("ALLOWED_ORIGIN_HOST", "127.0.0.1")  # or domain
HONEYPOT_FIELD      = os.environ.get("HONEYPOT_FIELD", "hp_website")


# Import analytics/behavior tracking functions
from project.analyze_events import (
    save_session_result,
    compute_behavioral_metrics,
    compute_cognitive_metrics,
    aggregate_metrics,
    export_all,
    erase_participant,
)


# ---------------------------
# Flask + Security Setup
# ---------------------------
app = Flask(__name__)

limiter = Limiter(
    key_func=get_remote_address,
    app=app,
    storage_uri=os.environ.get("LIMITER_STORAGE_URI","memory://"), 
    default_limits=["120 per minute"],
    headers_enabled=True
)
limiter.init_app(app)

# -------------------------------
# Dynamic honeypot cookie signing
# -------------------------------
import hmac
import hashlib
import secrets
from typing import Optional

# HMAC key (set in environment). IMPORTANT: set a long random secret in env before deploy.
HMAC_KEY = os.environ.get("HMAC_KEY")  # e.g. 64 hex chars from `secrets.token_hex(32)`
if not HMAC_KEY:
    # fallback for local dev only - strongly prefer setting HMAC_KEY in env
    HMAC_KEY = secrets.token_hex(32)
    # (You should export a proper HMAC_KEY in your shell/environment instead of relying on this.)

def generate_honeypot_field() -> str:
    """Return a short random honeypot field name, e.g. 'hp_ab12cd34'."""
    return "hp_" + secrets.token_hex(4)

def sign_val(val: str) -> str:
    """Return hex HMAC-SHA256 of val using HMAC_KEY."""
    key = HMAC_KEY.encode("utf-8")
    mac = hmac.new(key, val.encode("utf-8"), hashlib.sha256).hexdigest()
    return mac

def verify_val(val: str, sig: str) -> bool:
    """Verify HMAC signature constant-time; return True if match."""
    key = HMAC_KEY.encode("utf-8")
    expected = hmac.new(key, val.encode("utf-8"), hashlib.sha256).hexdigest()
    # use hmac.compare_digest for constant-time comparison
    return hmac.compare_digest(expected, sig)

@app.before_request
def rotate_honeypot_cookie():
    """
    Ensure a signed hp_field cookie exists on each session.
    Cookie format stored: "<field_name>|<sig>"
    - cookie is readable by JS (NOT HttpOnly) because client-side rotation reads it.
    - server verifies signature on use (see bot_tripwire update below).
    """
    try:
        raw = request.cookies.get("hp_field", "")
        valid_name: Optional[str] = None
        if raw and "|" in raw:
            name, sig = raw.split("|", 1)
            if name.startswith("hp_") and verify_val(name, sig):
                valid_name = name

        # If cookie missing or invalid -> generate new signed cookie
        if not valid_name:
            new_name = generate_honeypot_field()
            sig = sign_val(new_name)
            cookie_value = f"{new_name}|{sig}"
            # store for after_request to attach to outgoing response
            # don't directly call make_response here (Flask catch-alls make it messy)
            from flask import g
            g.hp_cookie_to_set = cookie_value
    except Exception:
        # never block user flow if sign/rotate fails
        pass


# -------------------------------
# Dynamic Honeypot Field Helper (Upgrade #4)
# -------------------------------

import secrets

def generate_honeypot_field():
    """Generate a random honeypot field name."""
    return "hp_" + secrets.token_hex(4)

@app.before_request
def rotate_honeypot_cookie():
    """
    Rotate honeypot field name occasionally for better bot resistance.
    Stores field name in user cookie 'hp_field' if missing.
    """
    if not request.cookies.get("hp_field"):
        from flask import g
        g.hp_cookie_to_get = generate_honeypot_field()

@app.after_request
def apply_honeypot_cookie(resp):
    """
    If rotate_honeypot_cookie scheduled a cookie (saved on g.hp_cookie_to_set),
    attach it to the response here so every response carries the cookie.
    """
    from flask import g
    try:
        if hasattr(g, "hp_cookie_to_set") and g.hp_cookie_to_set:
            # IMPORTANT: the cookie must be readable by client-side JS so we do NOT set HttpOnly=True
            resp.set_cookie(
                "hp_field",
                g.hp_cookie_to_set,
                max_age=60 * 60 * 24,   # 1 day
                httponly=False,         # JS needs to read it to set hidden input name
                samesite="Lax",
                path="/"
            )
    except Exception:
        # never block normal flow if cookie attach fails
        pass

    return resp

# ----------------------------
# Rate Limit JSON Handler (Upgrade #1)
# -----------------------------
from flask_limiter.errors import RateLimitExceeded

@app.errorhandler(RateLimitExceeded)
def handle_rate_limit(e):
    retry = getattr(e, "reset_in", 1)
    resp = jsonify({"error": "rate_limited", "retry_after": retry})
    resp.status_code = 429
    resp.headers["Retry-After"] = str(retry)
    return resp

# -----------------------------
# Host Allow-List Siteguard (Upgrade #2)
# -----------------------------
@app.before_request
def host_siteguard():
    # If allow-list not configured, skip
    if not ALLOWED_ORIGIN_HOST:
        return

    # Extract host portion without port
    host = (request.host or "").split(":")[0]

    # If mismatched, block + audit
    if host and host != ALLOWED_ORIGIN_HOST:
        audit_record(
            action="host_block",
            status="denied",
            extra={"seen_host": host, "path": request.path}
        )
        return jsonify({"error": "host_not_allowed"}), 403


# ------------------------------------------------------------------
# Honeypot + Bot Tripwire (Upgrade #3) - signed cookie-aware version
# ------------------------------------------------------------------
def bot_tripwire():
    """
    Return Flask response to block if bot is suspected; otherwise return None.
    Uses signed hp_field cookie of form: "<field_name>|<sig>" where sig = HMAC(name).
    Falls back to env HONEYPOT_FIELD if cookie missing/invalid.
    """
    honeypot_val = None
    hp_name = None

    # --- Read and verify signed cookie if present ---
    try:
        raw = request.cookies.get("hp_field", "")
        if raw and "|" in raw:
            name, sig = raw.split("|", 1)
            # accept only names that look like our hp_ prefix and verify signature
            if name.startswith("hp_") and verify_val(name, sig):
                hp_name = name
    except Exception:
        # don't break request flow on verification errors
        hp_name = None

    # Fallback to env/default configured name
    if not hp_name:
        hp_name = os.environ.get("HONEYPOT_FIELD", "hp_website")

    # --- Extract submitted value from possible input types ---
    if request.is_json:
        body = request.get_json(silent=True) or {}
        honeypot_val = (body.get(hp_name) or "").strip()
    else:
        honeypot_val = (request.form.get(hp_name) or "").strip()

    # check querystring as well (rare, but cover all)
    if not honeypot_val:
        honeypot_val = (request.args.get(hp_name) or "").strip()

    # If honeypot field is filled -> suspicious -> log + block
    if honeypot_val:
        try:
            audit_record(
                action="honeypot_trigger",
                actor="unknown",
                subject=request.path,
                status="denied",
                extra={"hp_field": hp_name, "ip": request.remote_addr}
            )
        except Exception:
            pass

        return jsonify({"error": "bot_detected"}), 400

    return None

# ------------------------------
# Fake / Decoy Endpoints + Snare
# ------------------------------
from flask import render_template, request, redirect, url_for, make_response, jsonify

@app.route("/decoy", methods=["GET"])
def decoy_page():
    """
    Public decoy page that looks like a sensitive endpoint.
    Useful to attract scanners / bots. We show a fake input and
    wire it to /decoy_submit which logs everything.
    """
    # note: server will provide hp_field template variable (index route already does)
    hp_field = request.cookies.get("hp_field") or os.environ.get("HONEYPOT_FIELD", "hp_website")
    return render_template("decoy.html", hp_field=hp_field)


@app.route("/decoy_submit", methods=["POST"])
def decoy_submit():
    """
    Accept both form and JSON submissions to the decoy. Always log an audit line
    and then show a benign message. If honeypot field was filled, bot_tripwire()
    will normally already have blocked earlier — but we log again for visibility.
    """
    # gather useful info
    try:
        body = request.get_json(silent=True) or {}
    except Exception:
        body = {}

    form = request.form or {}
    # collect a shallow copy of fields (don't store raw PII)
    fields = {}
    fields.update({k: ("<redacted>" if ("password" in k.lower() or "secret" in k.lower()) else v) for k, v in form.items()})
    fields.update({k: ("<redacted>" if ("password" in k.lower() or "secret" in k.lower()) else v) for k, v in body.items()})

    try:
        audit_record(
            action="decoy_hit",
            actor="unknown",
            subject=request.path,
            status="seen",
            extra={"ip": request.remote_addr, "via": "form_or_json", "fields": fields}
        )
    except Exception:
        pass

    # Optionally respond with a snare page that adds jitter to browser (client-side)
    return render_template("decoy_thanks.html"), 200


@app.route("/snare", methods=["POST"])
def snare_endpoint():
    """
    Lightweight API snare used by decoy JS. Collects client-side signals (UA, screen, time)
    and writes an audit log. Designed to catch automated clients that fire scripts or post
    fields that human users wouldn't.
    """
    data = request.get_json(silent=True) or {}
    try:
        audit_record(
            action="snare_trigger",
            actor="unknown",
            subject=request.path,
            status="collected",
            extra={
                "ip": request.remote_addr,
                "ua": request.headers.get("User-Agent"),
                "payload": {k: v for k, v in data.items()}
            }
        )
    except Exception:
        pass

    return jsonify({"ok": True}), 200


@app.route("/fake-login", methods=["GET", "POST"])
def fake_login():
    """
    A deceptive login page (non-functional). Logs any attempts.
    """
    if request.method == "POST":
        # log attempt but don't authenticate
        username = request.form.get("username", "")
        # purposely don't store raw password - only indicator length/exists
        attempted = {
            "username": username,
            "password_provided": bool(request.form.get("password"))
        }
        try:
            audit_record(
                action="fake_login_attempt",
                actor="unknown",
                subject=request.path,
                status="attempted",
                extra={"ip": request.remote_addr, "attempt": attempted}
            )
        except Exception:
            pass

        # show a benign "processing" page to hold the actor
        return render_template("fake_login_wait.html"), 200

    # GET: show the fake login form
    hp_field = request.cookies.get("hp_field") or os.environ.get("HONEYPOT_FIELD", "hp_website")
    return render_template("fake_login.html", hp_field=hp_field)


# ------------------------------
# ADMIN AUTHENTICATION
# ------------------------------

def admin_required(f):
    """Decorator to protect sensitive routes using rotating admin token."""
    @wraps(f)
    def decorated(*args, **kwargs):
        token_cfg = get_admin_token()
        if not token_cfg:
            return jsonify({"error": "Admin token not configured"}), 500

        auth = request.headers.get("Authorization", "")
        if auth.startswith("Bearer "):
            provided = auth.split(" ", 1)[1].strip()
        else:
            provided = request.headers.get("X-ADMIN-TOKEN", "").strip() or auth.strip()

        if provided != token_cfg:
            try:
                audit_record(
                    action="admin_access_denied",
                    actor="unknown",
                    subject=request.path,
                    status="denied",
                    extra={"ip": request.remote_addr}
                )
            except Exception:
                pass
            return jsonify({"error": "Unauthorized"}), 401

        return f(*args, **kwargs)
    return decorated

# --------------------------
#  ADMIN TOKEN HELPERS (Section 1)
# --------------------------
def get_admin_token() -> str:
    """Always read the current admin token from env to support live rotation."""
    return os.environ.get("ADMIN_TOKEN", "").strip()

def extract_admin_token_from_request() -> str:
    """Accept Authorization: Bearer <token> or X-ADMIN-TOKEN: <token> (or raw Authorization)."""
    auth = request.headers.get("Authorization", "")
    if auth.startswith("Bearer "):
        return auth.split(" ", 1)[1].strip()
    return (request.headers.get("X-ADMIN-TOKEN", "").strip()
            or auth.strip())

# --------------------------
#  APP INITIALIZATION
# --------------------------

# Guardrail 2: Limit max request body to 1 MB
app.config["MAX_CONTENT_LENGTH"] = 1 * 1024 * 1024


CONSENT_VERSION = "v1.0"
CORRECT_ANSWER = "23"  # change logic later if needed

# Folder setup
BASE_DIR = os.path.dirname(__file__)
LOG_DIR = os.path.join(BASE_DIR, "logs")
os.makedirs(LOG_DIR, exist_ok=True)

CONSENT_LOG = os.path.join(LOG_DIR, "consent_log.jsonl")
DATA_LOG = os.path.join(LOG_DIR, "data_log.jsonl")
AUDIT_LOG = os.path.join(LOG_DIR, "audit_log.jsonl")

# Set admin token via environment
def get_admin_token():
    # Primary: environment
    token = os.environ.get("ADMIN_TOKEN")
    if token:
        return token.strip()

    # Secondary: optional file fallback
    token_path = os.environ.get("ADMIN_TOKEN_FILE") or os.path.join(LOG_DIR, "admin_token.txt")
    try:
        with open(token_path, "r", encoding="utf-8") as f:
            token = f.read().strip()
            return token or None
    except Exception:
        return None

# --------------------------
#  UTILITIES
# --------------------------
# ---------- Secure JSONL logging with rotation + tamper-evident chain ----------

def _lim(val, default):
    try:
        return int(val)
    except Exception:
        return default

LOG_MAX_BYTES = _lim(os.environ.get("LOG_MAX_BYTES", 512 * 1024), 512 * 1024)  # 512 KB default
LOG_BACKUPS   = _lim(os.environ.get("LOG_BACKUPS", 5), 5)                     # keep 5 backups
LOG_HMAC_KEY_HEX = os.environ.get("LOG_HMAC_KEY", "").strip()                 # set to random hex for tamper-evidence

def _rotate_file_if_needed(path: str):
    try:
        if not os.path.exists(path):
            return
        if os.path.getsize(path) <= LOG_MAX_BYTES:
            return
        # rotate: .4 -> .5, .3 -> .4, ... path -> .1
        for i in range(LOG_BACKUPS, 0, -1):
            src = f"{path}.{i}" if i > 1 else path
            dst = f"{path}.{i+1}" if i > 0 else None
            if os.path.exists(src):
                if i == LOG_BACKUPS:
                    try:
                        os.remove(f"{path}.{LOG_BACKUPS+1}")
                    except Exception:
                        pass
                os.rename(src, f"{path}.{i+1}")
        # create fresh file
        open(path, "a", encoding="utf-8").close()
    except Exception as e:
        # last resort: don't crash app because rotation failed
        print(f"[WARN] rotation failed for {path}: {e}")

def _last_chain_hmac(path: str) -> str | None:
    """Read last JSONL line's _h value to chain HMACs; return None if unavailable."""
    if not os.path.exists(path):
        return None
    try:
        with open(path, "rb") as f:
            f.seek(0, os.SEEK_END)
            size = f.tell()
            # read from the end in small chunk
            step = min(4096, size)
            f.seek(max(0, size - step))
            tail = f.read().decode("utf-8", errors="ignore")
        lines = [ln for ln in tail.strip().splitlines() if ln.strip()]
        if not lines:
            return None
        last = lines[-1]
        try:
            j = json.loads(last)
            return j.get("_h")
        except Exception:
            return None
    except Exception:
        return None

def _sign_line(payload_bytes: bytes, prev_h: str | None) -> str | None:
    """Return hex HMAC over (prev_h||payload) if LOG_HMAC_KEY_HEX is set."""
    if not LOG_HMAC_KEY_HEX:
        return None
    try:
        key = bytes.fromhex(LOG_HMAC_KEY_HEX)
    except ValueError:
        return None
    hm = hmac.new(key, digestmod=hashlib.sha256)
    if prev_h:
        hm.update(prev_h.encode("utf-8"))
    hm.update(payload_bytes)
    return hm.hexdigest()

def append_jsonl_secure(path: str, obj: dict):
    """
    Append one JSON object per line with:
      - size-based rotation
      - optional tamper-evident hash chain (_h with previous link _p)
    """
    _rotate_file_if_needed(path)

    # prepare
    prev_h = _last_chain_hmac(path)
    # attach signed fields non-destructively
    to_write = dict(obj)
    if LOG_HMAC_KEY_HEX:
        # NOTE: we compute HMAC over the line WITHOUT _h, then store _h and _p
        payload_bytes = json.dumps(to_write, ensure_ascii=False, separators=(",", ":")).encode("utf-8")
        h = _sign_line(payload_bytes, prev_h)
        to_write["_p"] = prev_h  # previous hash (or None)
        to_write["_h"] = h       # current hash (or None if key invalid)

    line = json.dumps(to_write, ensure_ascii=False)
    with open(path, "a", encoding="utf-8") as f:
        f.write(line + "\n")

def now_iso():
    return datetime.datetime.now(datetime.timezone.utc).astimezone().isoformat()

def ip_hash(ip):
    if not ip:
        return ""
    return hashlib.sha256(ip.encode("utf-8")).hexdigest()

def bot_tripwire():
    """
    Return a Flask Response to block if bot is suspected; otherwise return None.
    Uses a dynamic honeypot field name stored in cookie 'hp_field' if present,
    otherwise falls back to HONEYPOT_FIELD (env/default).
    """
    honeypot_val = None

    # Determine expected honeypot field name (cookie preferred)
    hp_name = request.cookies.get("hp_field") or os.environ.get("HONEYPOT_FIELD", "hp_website")

    # Handle JSON bodies (API-style)
    if request.is_json:
        body = request.get_json(silent=True) or {}
        honeypot_val = (body.get(hp_name) or "").strip()
    else:
        # Form submissions
        honeypot_val = (request.form.get(hp_name) or "").strip()

    # If honeypot field is filled -> suspicious -> block + audit
    if honeypot_val:
        try:
            audit_record(
                action="honeypot_trigger",
                actor="unknown",
                subject=request.path,
                status="denied",
                extra={"hp_field": hp_name, "ip": request.remote_addr}
            )
        except Exception:
            pass

        return jsonify({"error": "bot_detected"}), 400

    return None

def audit_record(action: str,
                 actor: str = None,
                 subject: str = None,
                 status: str = None,
                 extra: dict | None = None,
                 notes: str | None = None):
    """Append a structured audit line to AUDIT_LOG (JSONL)."""
    # Back-compat: allow callers to pass notes=... (string)
    if notes:
        if isinstance(extra, dict) and extra:
            extra = {"notes": notes, **extra}
        else:
            extra = {"notes": notes}

    try:
        rec = {
            "ts": now_iso(),
            "ip": request.remote_addr if request else None,
            "action": action,
            "actor": actor,
            "subject": subject,
            "status": status,
            "extra": extra or {},
        }
    except RuntimeError:
        rec = {
            "ts": now_iso(),
            "ip": None,
            "action": action,
            "actor": actor,
            "subject": subject,
            "status": status,
            "extra": extra or {},
        }

    append_jsonl_secure(AUDIT_LOG, rec)

def require_admin(f):
    """Decorator identical to admin_required (compatibility)."""
    @wraps(f)
    def wrapper(*args, **kwargs):
        token_cfg = get_admin_token()
        if not token_cfg:
            return jsonify({"error": "Admin token not configured"}), 500

        auth = request.headers.get("Authorization", "")
        if auth.startswith("Bearer "):
            provided = auth.split(" ", 1)[1].strip()
        else:
            provided = request.headers.get("X-ADMIN-TOKEN", "").strip() or auth.strip()

        if provided != token_cfg:
            try:
                audit_record(
                    action="admin_access_denied",
                    actor="unknown",
                    subject=request.path,
                    status="denied",
                    extra={"ip": request.remote_addr}
                )
            except Exception:
                pass
            return jsonify({"error": "Unauthorized"}), 401

        return f(*args, **kwargs)
    return wrapper

# keep compatibility with routes using @admin_required
admin_required = require_admin

#  VALIDATION HELPERS
def validate_json_field(data, field, expected_type):
    """Return (True, value) or (False, error message)."""
    if field not in data:
        return False, f"Missing field: {field}"
    if not isinstance(data[field], expected_type):
        return False, f"Field '{field}' must be {expected_type.__name__}"
    return True, data[field]

def require_json(f):
    """Ensure request is JSON."""
    @wraps(f)
    def wrapper(*args, **kwargs):
        if not request.is_json:
            return jsonify({"error": "Request must be JSON"}), 400
        return f(*args, **kwargs)
    return wrapper

def validate_behavioral_session(s: dict):
    req = ["participant_id", "task_id", "start_ts", "end_ts", "events"]
    for k in req:
        if k not in s: return False, f"missing '{k}'"
    if not isinstance(s["events"], list): return False, "'events' must be a list"
    for i, e in enumerate(s["events"]):
        if not isinstance(e, dict): return False, f"event[{i}] must be object"
        if "type" not in e or "ts" not in e: return False, f"event[{i}] missing 'type' or 'ts'"
        if not isinstance(e["type"], str): return False, f"event[{i}].type must be string"
        if not isinstance(e["ts"], int): return False, f"event[{i}].ts must be int (ms)"
    return True, None

def validate_cognitive_session(s: dict):
    if "participant_id" not in s: return False, "missing 'participant_id'"
    if "task_id" not in s: return False, "missing 'task_id'"
    if "modules" not in s or not isinstance(s["modules"], list):
        return False, "'modules' must be a list"
    for mi, m in enumerate(s["modules"]):
        if not isinstance(m, dict): return False, f"modules[{mi}] must be object"
        if "module_name" not in m: return False, f"modules[{mi}] missing 'module_name'"
        qs = m.get("questions", [])
        if not isinstance(qs, list): return False, f"modules[{mi}].questions must be list"
        for qi, q in enumerate(qs):
            if not isinstance(q, dict): return False, f"q[{qi}] in module[{mi}] must be object"
            for k in ["question_id", "correct", "time_taken_seconds"]:
                if k not in q: return False, f"q[{qi}] in module[{mi}] missing '{k}'"
    return True, None


# --------------------------
#  MAIN ROUTES
# --------------------------
@limiter.limit("30 per minute")
@app.route('/', methods=['GET', 'POST'])
def index():
    result = None
    user_answer = ""
    participant_id = request.cookies.get("participant_id")

    if request.method == 'POST':
        # Require consent
        if not participant_id:
            result = "no_consent"
            user_answer = request.form.get('answer', '').strip()
            ok = (user_answer == CORRECT_ANSWER)
            result = "correct" if ok else "wrong"

            # Log event (anonymized answer)
            log = {
                "participant_id": participant_id,
                "timestamp": now_iso(),
                "task_id": "sequence_test_001",
                "answer_hash": hashlib.sha256(user_answer.encode("utf-8")).hexdigest(),
                "result": result
            }
            append_jsonl_secure(DATA_LOG, log)
            audit_record(
                action="submit_answer",
                actor=f"participant:{participant_id}",
                subject="sequence_test_001",
                status="ok" if result == "correct" else "wrong",
                extra={"target_id": participant_id, "result": result},
            )
    return render_template(
        'index.html',
        result=result,
        user_answer=user_answer,
        hp_field=request.cookies.get("hp_field") or HONEYPOT_FIELD or "hp_website"
    )


@limiter.limit("5 per minute")
@app.route('/consent', methods=['POST'])
def consent():
    trip = bot_tripwire()
    if trip:
        return trip
    """Record participant consent."""
    ip = request.remote_addr or ""
    participant_id = str(uuid.uuid4())

    record = {
        "participant_id": participant_id,
        "timestamp": now_iso(),
        "consent_version": CONSENT_VERSION,
        "consent_given": True,
        "ip_hash": ip_hash(ip)
    }

    append_jsonl_secure(CONSENT_LOG, record)
    audit_record(actor=f"participant:{participant_id}", action="consent_given")

    resp = make_response(jsonify({"ok": True, "participant_id": participant_id}))
    resp.set_cookie("participant_id", participant_id, max_age=60*60*24*365, httponly=True, samesite="Lax")
    return resp


# ============================================================
# ANALYTICS ROUTES
# ============================================================
@app.route("/submit_result", methods=["POST"])
@limiter.limit("20 per minute") 
def submit_result():
    trip = bot_tripwire()
    if trip:
        return trip
    """
    Accepts JSON body with a session object.
    Automatically detects type (behavioral or cognitive)
    and computes the correct metrics.
    """
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400

    session = request.get_json()


    # -------------------------------------------
    # VALIDATION LAYER: reject malformed sessions
    # -------------------------------------------
    if isinstance(session, dict) and "events" in session:
        ok, msg = validate_behavioral_session(session)
        if not ok:
            return jsonify({"error": msg}), 400

    elif isinstance(session, dict) and "modules" in session:
        ok, msg = validate_cognitive_session(session)
        if not ok:
            return jsonify({"error": msg}), 400
    # -------------------------------------------


    saved = save_session_result(session)

    # detect session type and compute metrics
    if isinstance(saved, dict) and "events" in saved:
        metrics = compute_behavioral_metrics(saved)
        session_type = "behavioral"
    elif isinstance(saved, dict) and "modules" in saved:
        metrics = compute_cognitive_metrics(saved)
        session_type = "cognitive"
    else:
        metrics = {"note": "Unknown data type; no metrics computed"}
        session_type = "unknown"
    # ✅ AUDIT LOG HERE
    audit_record(
        actor=f"participant:{saved.get('participant_id', 'unknown')}",
        action="submit_result",
        target_id=saved.get("task_id"),
        notes=f"type={session_type}"
    )
    return jsonify({"saved": saved, "metrics": metrics}), 201

# -----------------------------------------
# AUDIT LOG ROUTE
# -----------------------------------------
@app.route("/audit/last/<int:n>", methods=["GET"])
@admin_required
@limiter.limit("10 per minute") 
def last_audit(n):
    try:
        entries = []
        with open(AUDIT_LOG, "r", encoding="utf-8") as f:
            for line in f:
                entries.append(json.loads(line))
        return jsonify({"audit": entries[-n:]}), 200
    except Exception as e:
        return jsonify({"error": "failed to read audit log", "detail": str(e)}), 500

@app.route("/metrics", methods=["GET"])
@admin_required
@limiter.limit("2 per second")
def metrics():
    """Return aggregated metrics."""
    try:
        agg = aggregate_metrics()
     
        # ✅ AUDIT LOG: admin requested aggregated metrics
        audit_record(
            actor="admin",
            action="view_metrics",
            notes=f"returned_items={len(agg)}"
        )

        return jsonify(agg), 200
    except Exception as e:
        return jsonify({"error": "metrics computation failed", "detail": str(e)}), 500

@app.route("/export", methods=["GET"])
@admin_required
@limiter.limit("5 per minute") 
def export():
    """Return all stored session rows (admin only)."""
    rows = export_all()


    #AUDIT LOG: admin exported data
    audit_record(
        actor="admin",
        action="export_all_data",
        notes=f"rows={len(rows)}"
    )

    return jsonify(rows), 200


@app.route("/erase/<participant_id>", methods=["DELETE"])
@admin_required
@limiter.limit("3 per minute")
def erase(participant_id):
    """Delete data for a participant ID (admin only)."""
    removed = erase_participant(participant_id)

     # ✅ AUDIT LOG: admin erased participant data
    audit_record(
        actor="admin",
        action="erase_participant",
        target_id=participant_id,
        notes=f"removed={removed}"
    )


    return jsonify({"removed": removed}), 200

@app.route("/data_type_summary", methods=["GET"])
@admin_required
@limiter.limit("20 per minute")
def data_type_summary():
    """Counts behavioral vs cognitive sessions."""
    try:
        rows = export_all()
    except Exception as e:
        return jsonify({"error": "failed to read data", "detail": str(e)}), 500

    behavioral = cognitive = unknown = 0

    for r in rows:
        if isinstance(r, dict) and "events" in r:
            behavioral += 1
        elif isinstance(r, dict) and "modules" in r:
            cognitive += 1
        else:
            unknown += 1

    return jsonify({
        "behavioral_sessions": behavioral,
        "cognitive_sessions": cognitive,
        "unknown_sessions": unknown,
        "total": behavioral + cognitive + unknown
    }), 200


@app.route("/export/dashboard", methods=["GET"])
@admin_required
@limiter.limit("10 per minute")
def export_dashboard():
    """
    Returns chart-ready metrics for plotting progress over time.
    - Cognitive sessions -> accuracy%, avg time, avg hesitation, avg retries
    - Behavioral sessions -> performance_score, total_time, hints, retries, hesitation
    """
    try:
        rows = export_all()   # already implemented in your project
    except Exception as e:
        return jsonify({"error": "failed to read data", "detail": str(e)}), 500

    # Structures to hold chart series
    cognitive = {
        "index": [],
        "accuracy_pct": [],
        "avg_time_s": [],
        "avg_hesitation_s": [],
        "avg_retries": [],
    }

    behavioral = {
        "index": [],
        "performance_score": [],
        "total_time_s": [],
        "hints": [],
        "retries": [],
        "hesitation_s": [],
    }

    cog_i = beh_i = 0

    # Loop through every session record
    for entry in rows:

        # ==========================================================
        # COGNITIVE SESSION (modules → questions)
        # ==========================================================
        if isinstance(entry, dict) and "modules" in entry:
            modules = entry.get("modules", [])

            total_questions = 0
            correct = 0
            total_time = 0.0
            total_hesitation = 0.0
            total_retries = 0.0

            for m in modules:
                for q in m.get("questions", []):
                    total_questions += 1
                    if q.get("correct"):
                        correct += 1
                    total_time += q.get("time_taken_seconds", 0) or 0
                    total_hesitation += q.get("hesitation_seconds", 0) or 0
                    total_retries += q.get("retries", 0) or 0

            if total_questions > 0:
                cog_i += 1
                cognitive["index"].append(cog_i)
                cognitive["accuracy_pct"].append(round((correct / total_questions) * 100, 2))
                cognitive["avg_time_s"].append(round(total_time / total_questions, 2))
                cognitive["avg_hesitation_s"].append(round(total_hesitation / total_questions, 2))
                cognitive["avg_retries"].append(round(total_retries / total_questions, 2))


        # ==========================================================
        # BEHAVIORAL SESSION (events → timestamps)
        # ==========================================================
        elif isinstance(entry, dict) and "events" in entry:

            start = entry.get("start_ts")
            end = entry.get("end_ts")
            total_ms = max(0, (end - start)) if (start and end) else None
            events = entry.get("events", [])

            # Count hints + retries
            hints = sum(1 for e in events if e.get("type") == "hint")
            retries = sum(1 for e in events if e.get("type") == "retry")

            # Hesitation calculation (gaps > 1500ms)
            timestamps = sorted([e.get("ts") for e in events if isinstance(e.get("ts"), (int, float))])
            hesitation_ms = 0
            for a, b in zip(timestamps, timestamps[1:]):
                gap = b - a
                if gap > 1500:
                    hesitation_ms += gap

            # Performance score (lightweight version of compute_behavioral_metrics)
            score = 100
            if total_ms is not None:
                score -= (total_ms / 1000.0) * 0.5
            score -= hints * 5
            score -= retries * 3
            score = round(max(0, score), 2)

            beh_i += 1
            behavioral["index"].append(beh_i)
            behavioral["performance_score"].append(score)
            behavioral["total_time_s"].append(round(total_ms / 1000.0, 3) if total_ms else None)
            behavioral["hints"].append(hints)
            behavioral["retries"].append(retries)
            behavioral["hesitation_s"].append(round(hesitation_ms / 1000.0, 3))

        # ==========================================================
        # UNKNOWN ENTRY (should not happen but safe to ignore)
        # ==========================================================
        else:
            continue

    return jsonify({
        "cognitive": cognitive,
        "behavioral": behavioral
    }), 200


# ============================================================
# HEALTH CHECK / STATUS
# ============================================================

def _count_jsonl_lines(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return sum(1 for _ in f)
    except Exception:
        return None  # unreadable or missing

def _read_json_file(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return True, json.load(f)
    except FileNotFoundError:
        return False, None
    except Exception:
        return True, None  # exists but invalid JSON

@limiter.limit("30 per minute")
@app.route("/status", methods=["GET"])
def status():
    # Uses variables you already defined earlier in app.py:
    # BASE_DIR, LOG_DIR, CONSENT_LOG, DATA_LOG, AUDIT_LOG
    session_file = os.path.join(BASE_DIR, "session_data.json")

    exists = {
        "log_dir": os.path.isdir(LOG_DIR),
        "session_data_json": os.path.isfile(session_file),
        "consent_log_jsonl": os.path.isfile(CONSENT_LOG),
        "data_log_jsonl": os.path.isfile(DATA_LOG),
        "audit_log_jsonl": os.path.isfile(AUDIT_LOG),
    }

    session_exists, session_data = _read_json_file(session_file)
    session_parsable = (session_data is not None) if session_exists else False

    consent_count = _count_jsonl_lines(CONSENT_LOG) if exists["consent_log_jsonl"] else None
    audit_count = _count_jsonl_lines(AUDIT_LOG) if exists["audit_log_jsonl"] else None
    data_log_count = _count_jsonl_lines(DATA_LOG) if exists["data_log_jsonl"] else None

    writable = {
        "log_dir_writable": os.access(LOG_DIR, os.W_OK),
        "base_dir_writable": os.access(BASE_DIR, os.W_OK),
    }

    admin_token_configured = bool(get_admin_token())

    if isinstance(session_data, list):
        session_count = len(session_data)
    elif isinstance(session_data, dict):
        session_count = 1
    else:
        session_count = 0 if session_parsable else None

    ok_flags = [
        exists["log_dir"],
        writable["log_dir_writable"],
        session_exists,
        session_parsable,
        admin_token_configured,
    ]
    status_level = "ok" if all(ok_flags) else "degraded"

    return jsonify({
        "status": status_level,
        "files": exists,
        "writable": writable,
        "admin_token_configured": admin_token_configured,
        "counts": {
            "sessions": session_count,
            "consent_log_lines": consent_count,
            "audit_log_lines": audit_count,
            "data_log_lines": data_log_count,
        },
    }), 200


# --------------------------
#  COMPLIANCE ENDPOINTS
# --------------------------

def anonymize_data_for_participant(pid):
    """Replace participant_id in DATA_LOG with 'erased_' token (keeps audit)."""
    erased_token = f"erased_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"
    temp_path = DATA_LOG + ".tmp"

    if not os.path.exists(DATA_LOG):
        return False, "No data log found."

    try:
        with open(DATA_LOG, "r", encoding="utf-8") as fin, open(temp_path, "w", encoding="utf-8") as fout:
            for line in fin:
                try:
                    j = json.loads(line)
                except:
                    fout.write(line)
                    continue
                if j.get("participant_id") == pid:
                    j["participant_id"] = erased_token
                    j["erased"] = True
                    j["erasure_timestamp"] = now_iso()
                fout.write(json.dumps(j, ensure_ascii=False) + "\n")

        backup = DATA_LOG + ".bak." + datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        os.rename(DATA_LOG, backup)
        os.rename(temp_path, DATA_LOG)
        return True, f"Entries anonymized; backup at {backup}"
    except Exception as e:
        if os.path.exists(temp_path):
            os.remove(temp_path)
        return False, str(e)


@app.route('/export/<participant_id>', methods=['GET'])
def export_data(participant_id):
    """Allow admin or participant to export their data."""
    # Always read current admin token (supports rotation)
    token_cfg = get_admin_token()

    # Accept Authorization: Bearer <token> OR X-ADMIN-TOKEN: <token>
    provided = extract_admin_token_from_request()

    cookie_pid = request.cookies.get("participant_id")
    if token_cfg and provided and hmac.compare_digest(provided, token_cfg):
        actor = "admin"
    elif cookie_pid == participant_id:
        actor = f"participant:{participant_id}"
    else:
        audit_record(actor="unauthorized", action="export_attempt", subject=participant_id, status="denied",
                     extra={"ip": request.remote_addr})
        return jsonify({"error": "Unauthorized"}), 401

    results = []
    if os.path.exists(DATA_LOG):
        with open(DATA_LOG, "r", encoding="utf-8") as f:
            for line in f:
                try:
                    j = json.loads(line)
                    if j.get("participant_id") == participant_id:
                        results.append(j)
                except Exception:
                    pass

    audit_record(actor=actor, action="export", subject=participant_id,
                 status="ok", extra={"count": len(results)})
    return jsonify({"participant_id": participant_id, "events": results})


@app.route('/erase', methods=['POST'])
def erase_self():
    """Participant-initiated erasure (anonymizes logs)."""
    pid = request.cookies.get("participant_id")
    if not pid:
        return jsonify({"error": "No participant cookie found"}), 400

    data = request.get_json() or {}
    if not data.get("confirm"):
        return jsonify({"error": "Please confirm erasure by sending {\"confirm\": true}"}), 400

    ok, msg = anonymize_data_for_participant(pid)
    audit_record(actor=f"participant:{pid}", action="erase_request", notes=msg)
    if ok:
        resp = jsonify({"ok": True, "message": "Your data has been anonymized."})
        resp.set_cookie("participant_id", "", expires=0)
        return resp
    else:
        return jsonify({"error": "Erase failed", "details": msg}), 500


@app.route('/admin/delete_participant/<participant_id>', methods=['POST'])
@require_admin
def admin_delete(participant_id):
    """Admin-only permanent delete (backed up before removal)."""
    if not os.path.exists(DATA_LOG):
        return jsonify({"error": "No data log"}), 400

    backup = DATA_LOG + ".bak." + datetime.datetime.now().strftime("%Y%m%d%H%M%S")

    try:
        os.rename(DATA_LOG, backup)
        kept, removed = 0, 0
        with open(backup, "r", encoding="utf-8") as fin, open(DATA_LOG, "w", encoding="utf-8") as fout:
            for line in fin:
                try:
                    j = json.loads(line)
                    if j.get("participant_id") == participant_id:
                        removed += 1
                        continue
                    fout.write(json.dumps(j, ensure_ascii=False) + "\n")
                    kept += 1
                except:
                    fout.write(line)
                    kept += 1
        audit_record(actor="admin", action="delete_participant",
                     target_id=participant_id, notes=f"removed {removed} entries; backup at {backup}")
        return jsonify({"ok": True, "removed": removed, "backup": backup})
    except Exception as e:
        if os.path.exists(backup) and not os.path.exists(DATA_LOG):
            os.rename(backup, DATA_LOG)
        return jsonify({"error": "Failed delete", "details": str(e)}), 500


# --------------------------
#  METADATA ENDPOINT (HTML + JSON)
# --------------------------

@app.route('/metadata', methods=['GET'])
def metadata():
    """Expose compliance and model metadata (HTML for browser, JSON for API)."""
    dpiapath = os.path.join(BASE_DIR, "DPIA.md")
    modelpath = os.path.join(BASE_DIR, "model_card.md")

    def safe_read(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                return f.read(2000)
        except FileNotFoundError:
            return "N/A"

    dpia_text = safe_read(dpiapath)
    model_text = safe_read(modelpath)

    # If the user requested JSON explicitly
    if request.headers.get('Accept') == 'application/json':
        return jsonify({
            "project": "Cognitive-Behavioral Analytics MVP",
            "dpiaversion": "1.0",
            "model_version": "1.0",
            "consent_version": CONSENT_VERSION,
            "contact": "jirehkenneth2001@gmail.com",
            "maintainer": "Jireh Kenneth-Usen",
            "location": "Lagos, Nigeria",
            "license": "Internal research / educational prototype",
            "last_review": datetime.datetime.now().strftime("%Y-%m-%d"),
            "dpia_excerpt": dpia_text[:300],
            "modelcard_excerpt": model_text[:300]
        })

    # Otherwise, return a pretty HTML view
    html = f"""
    <html>
    <head>
        <title>System Metadata – Compliance Overview</title>
        <link rel="stylesheet" href="/static/style.css">
        <style>
            body {{ background:#f8f9fa; color:#222; font-family:Inter, sans-serif; padding:2rem; }}
            h1 {{ color:#d6336c; }}
            pre {{ background:#fff; padding:1rem; border-radius:0.5rem; overflow-x:auto; }}
            .card {{ background:white; box-shadow:0 2px 6px rgba(0,0,0,0.1); border-radius:1rem; padding:1.5rem; margin-bottom:2rem; }}
            .meta-title {{ color:#444; font-size:1.2rem; font-weight:600; margin-bottom:0.5rem; }}
        </style>
    </head>
    <body>
        <h1>Compliance & Model Metadata</h1>

        <div class="card">
            <div class="meta-title">Project:</div>
            Cognitive-Behavioral Analytics MVP<br>
            <b>Maintainer:</b> Jireh Kenneth-Usen<br>
            <b>Contact:</b> jirehkenneth2001@gmail.com<br>
            <b>Consent Version:</b> {CONSENT_VERSION}<br>
            <b>DPIA Version:</b> 1.0<br>
            <b>Model Version:</b> 1.0<br>
            <b>Last Review:</b> {datetime.datetime.now().strftime("%Y-%m-%d")}<br>
        </div>

        <div class="card">
            <div class="meta-title">DPIA Excerpt</div>
            <pre>{dpia_text[:600]}</pre>
        </div>

        <div class="card">
            <div class="meta-title">Model Card Excerpt</div>
            <pre>{model_text[:600]}</pre>
        </div>

        <p style="text-align:center; color:#888;">© 2025 Jireh Kenneth-Usen – Internal Research Prototype</p>
    </body>
    </html>
    """

    return html

# --------------------------
#  RUN SERVER
# --------------------------

if __name__ == "__main__":
    print("✅ Flask app running on http://127.0.0.1:5000")
    print("Admin token set:", bool(get_admin_token()))
    app.run(host="127.0.0.1", port=5000, debug=False)

